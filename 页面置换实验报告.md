## 页面置换实验报告

### 算法设计思想

通过理论课的学习，我们知道最优的页面置换算法是OPT：替换在将来最晚被访问的页面。但是在实际的应用过程中，由于我们无法预知页面出现的顺序，所以OPT从实际的角度来说是不能实现的。所以我们只能够退而求其次实现一些近似OPT的算法，我首先考虑的是以下算法：

+ LRU：置换在最近一段时间里最久没有使用过的页面。
+ LFU：置换在最近一段时间内使用次数最小的页面。

LRU算法利用了程序的局部性原理，优先替换最久没有使用过的页面，但是可能会出现一些临时使用的页面，这些页面只使用了很少的次数，但是LRU算法将它完全等同于一些长期使用的页面进行处理。LFU在这一点上有自己的优势，考虑的是置换在最近一段时间内使用次数最小的页面，对于临时页面的置换有自己的优势，但是在程序局部性的处理上并没有LRU优秀。所以我希望能够设计出一种综合LRU和LFU优势的算法，使得在对于临时页面的处理上和程序的局部性的处理上都取得较好的效果。

具体的做法就是对第一次加入physic_memery的页面进行特殊处理，让其更容易被替换，也就对应着临时页面更容易被替换；当其在physic_memery中被命中时，采用LRU进行处理。也就是我们将出现次数为1的页面当成临时页面处理，出现至少两次的页面采用LRU算法。

首先给出优化之前的代码如下，并分析算法实现的技巧。

```c++
#include "pageReplace.h"
#define MAX_PAGE 12
#define get_Page(x) (x>>MAX_PAGE)

void pageReplace(long * physic_memery, long nwAdd) {
        static int clock = 0;
        static int age[64];
        static int page = 0;
        if (clock == 0) {
                for (int i = 0;i < 64; i++) {
                        age[i] = 0;
                }
        }
        clock++;
        if (page < 64) {
                long num = get_Page(nwAdd);
                for (int i = 0;i < page;i++) {
                        if (num == physic_memery[i]) {
                                age[i] = clock;
                                return;
                        }
                }
                physic_memery[page] = num;
                age[page] = clock - 400;
                page++;
                return;
        } else {
                long num = get_Page(nwAdd);
                int min = age[0];
                int index = 0;
                for (int i = 0;i < 64;i++) {
                        int time = age[i];
                        if (num == physic_memery[i]) {
                                age[i] = clock;
                                return;
                        }
                        if (time < min) {
                                min = time;
                                index = i;
                        }
                }
                physic_memery[index] = get_Page(nwAdd);
                age[index] = clock - 400;
        }
}
```

### 算法实现技巧

1. **采用数组来记录每个页面的年龄**

   传统的LRU算法使用**栈**记录页表的出现顺序，当访问某个页面的时候就将其移动到栈顶，这样栈底保存的就是最长时间没有被使用的页面结构。每一次置换页面需要遍历一次保存栈的数据结构，将页面移动到栈顶，如果页面不在栈中需要将栈底元素移除。但是在本次页面置换的要求如下：

   > 评分会综合程序运行时间、程序使用内存、总置换代价给出

   这也说明我们不仅需要考虑时间复杂度，也需要考虑空间复杂度。由于遍历保存页面的数据结构是必须的，如果使用链表存储栈的，虽然移动元素和删除元素所需要的时间为o(1)，但是栈空间复杂度较高；如果使用数组来存储栈的话，移动元素和删除元素的复杂度都为o(n)，但是存储空间较少。我希望能够综合两者的优点，使用数组存储，并且移动和删除元素所需要的时间都为o(1)。经过思考，我决定使用数组来存储页面出现的时间，并且遍历找出出现时间最小的页面，将其替换即可。这样能够实现较小的空间复杂度和在替换时较小的时间复杂度。

2. **结合LRU和LFU算法**

   由于程序除了具有时间局部性和空间局部性之外，也存在访问频率的问题，在之前被访问次数更多的页面，在之后也更可能被访问。所以我对于页面的年龄做了不同的处理。当页面第一次出现的时候，年龄会被设置为：

   ```c++
   age[index] = clock - 400;
   ```

   当页面在内存中被访问到第二次时，我们将其年龄设置为：

   ```c++
   age[i] = clock;
   ```

   换句话来说，我们认为目前只出现过一次的页面更有可能被替换，也就是其更有可能时临时页面。而当页面在内存中被再次命中的时候，其更有可能不是临时页面，可以采用LRU的通常的算法进行处理。

   通过在线的测评，我发现这样做能够明显减少页面替换的缺页损失。除此之外，将400换成不同的值，得到的缺页率并不一样，经过简单的调整，最终决定取400来达到一个相对较小的缺页率。

3. **当存放页面数page<64和page=64时采用不同的处理方式**

   使用page来表示已经在物理内存中的页面数目。当page<64的时候，即使当前需要访问的页面不在物理内存中的时候，也不需要替换，只需将其添加到当前物理内存数组的末尾就行。当page=64的时候，如果当前需要访问的页面不在物理内存中的时候，需要替换当前物理内存中age最小的页面。这两种操作是不同的，将其分开处理能够减少循环运行的时间。

### 竞速实验过程中的优化与改进

在本次竞速实验中，除了缺页率和空间复杂度之外，我们还希望代码能够实现更少的时间和更少的perf数。perf的定义是程序运行时总共需要的指令数目。

#### 针对运行时间的优化：

对于运行时间的优化时在竞速实验过程中我采用的主要的优化方式。其中分别对代码的结构和一些循环部分的细节进行了优化。

+ **使用register变量**

  一般情况下，c++中的变量的值时直接存放在内存中的。当程序中需要用到哪一个变量的值的时候，再将其送入CPU中的运算器，除此之外也可以直接将一些局部变量声明为register变量，在使用的时候直接可以从寄存器中去除并且参加运算。

  在循环结构中需要被频繁调用和修改的变量，声明为register变量会使得对这些变量的存取十分便捷。在优化之后的代码中，将循环体中需要改变和访问的变量都声明成了register变量。

  通过测试可以发现这register变量显著减少了程序的运行时间。

+ **优化循环结构**

  对于经常在循环中需要使用到的变量，我们不需要在每次循环的时候都计算一次这些变量的值，可以在每次循环之前都将这些值算出来，循环过程中不需要计算只需要使用即可。比如以下两个：

  ```c++
  long num = get_Page(nwAdd);
  int index = get_Page(nwAdd) & 0x3;

+ **优化运算方式**

  对于CPU来说，直接对变量进行位运算比乘法或者除法都要快的多，所以使用位运算来代替乘法和除法，以取得更短的CPU运算时间。比如：

  ```c++
  int index = get_Page(nwAdd) & 0x3;

#### 针对指令数的优化：

针对指令数的优化，我想到的一个办法就是减少循环的次数。在之前的设计中，每一次页面替换都需要遍历所有的物理页面。在优化的过程中，我认为可以结合计组中使用到的组相联的思想。将每次页面按照二进制的最后两位分成四组，每组16个。将后两位相同的页面的存放和替换都放到一组，这样每次循环就只需要遍历16个页面，能够极大减少循环的数目。

+ **采用组相联优化**

  将页面按照二进制的末尾两位分成四组。将默维尔为相同的页面的存放和替换都放在同一组，在最开头就获得页面所对应的组号：

  ```c++
  int index = get_Page(nwAdd) & 0x3;
  ```

  在对应的组内进行操作的方法和之前一样。分为组内的页面是否存放满，采取不同的方法进行处理，和之前的代码一样。

最终优化之后的代码如下：

```c++
#include "pageReplace.h"
#define MAX_PAGE 12
#define get_Page(x) (x>>MAX_PAGE)

void pageReplace(long * physic_memery, long nwAdd) {
	static int clock = 0;
	static int age[64] = {0};
	static int cache_page[4] = {0};
	clock++;
	long num = get_Page(nwAdd);
	int index = get_Page(nwAdd) & 0x3;
	if (cache_page[index] < 16) {
		register int tail = cache_page[index] + (index << 4);
		for (register int i = (index << 4);i < tail;i++) {
			if (num == physic_memery[i]) {
				age[i] = clock;
				return;
			}
		}
		physic_memery[tail] = num;
		age[tail] = clock - 400;
		cache_page[index]++;
		return;
	} else {
		register int min = clock;
		register int replace = 0;
		register int tail = (index + 1) << 4;
		for (register int i = index << 4;i < tail;i++) {
			int time = age[i];
			if (num == physic_memery[i]) {
				age[i] = clock;
				return;
			}
			if (time < min) {
				min = time;
				replace = i;
			}
		}
		physic_memery[replace] = num;
		age[replace] = clock - 400;
	}
}

```

### 本地测试情况

由于水平有限，没有生成能够很好体现程序局部性原理的数据。所以对于这一次实验的本地测试，全部使用的是课程组提供的数据。并且根据测试的结果自行反馈调整代码。

### 其他思考

1. 在实现算法的时候，我认识到除了OPT算法之外，其余的算法都有局限性，没有办法保证在所有情况下都取得最优解。LRU其实也是基于对程序局部性的预测，只能够保证在大多数情况下达到相对较小的缺页率。
2. 也许课程组可以适当提示一些应该如何生成数据的方法。

### 最终结果

+ 时间测试排名：8
+ perf测试排名：2